<!DOCTYPE html>
<html>
<head>
    <title>Snake</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial;
        }
        canvas {
            display: block;
            border: 2px solid #333;
        }
        #score {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
        }
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }
        #menu h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
        }
        #menu button {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }
        #menu button:hover {
            background: #45a049;
            transform: scale(1.05);
        }
        #nickname {
            padding: 10px;
            font-size: 16px;
            margin-bottom: 20px;
            width: 200px;
            text-align: center;
        }
        #boost {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 30px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            overflow: hidden;
        }
        #boost-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }
        #leaderboard {
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            color: white;
            width: 200px;
            z-index: 100;
        }
        #leaderboard h3 {
            margin: 0 0 10px 0;
            text-align: center;
            color: #4CAF50;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .leaderboard-you {
            color: #4CAF50;
            font-weight: bold;
        }
        #game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: white;
        }
        #game-over h2 {
            font-size: 36px;
            color: #4CAF50;
            margin-bottom: 20px;
        }
        #final-score {
            font-size: 24px;
            margin-bottom: 30px;
        }
        #skin-selector {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }
        .skin-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .skin-option.selected {
            border-color: white;
        }
        #controls-info {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="leaderboard">
        <h3>TOP PLAYERS</h3>
        <div id="leaderboard-entries"></div>
    </div>
    <div id="boost"><div id="boost-bar"></div></div>
    <div id="menu">
        <h1>SLITHER.IO CLONE</h1>
        <input type="text" id="nickname" placeholder="Enter your nickname" maxlength="15">
        <div id="skin-selector">
            <div class="skin-option selected" style="background: #FFFFFF;" data-color="#FFFFFF"></div>
            <div class="skin-option" style="background: #FF5252;" data-color="#FF5252"></div>
            <div class="skin-option" style="background: #FFEB3B;" data-color="#FFEB3B"></div>
            <div class="skin-option" style="background: #4CAF50;" data-color="#4CAF50"></div>
            <div class="skin-option" style="background: #2196F3;" data-color="#2196F3"></div>
            <div class="skin-option" style="background: #9C27B0;" data-color="#9C27B0"></div>
        </div>
        <button id="startBtn">START GAME</button>
        <button id="instructionsBtn">INSTRUCTIONS</button>
        <div id="controls-info">
            Move: Mouse/Touch | Boost: SPACE/Click
        </div>
    </div>
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">Score: 0</div>
        <button id="playAgainBtn">PLAY AGAIN</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const menuElement = document.getElementById('menu');
        const startBtn = document.getElementById('startBtn');
        const instructionsBtn = document.getElementById('instructionsBtn');
        const nicknameInput = document.getElementById('nickname');
        const boostElement = document.getElementById('boost');
        const boostBar = document.getElementById('boost-bar');
        const leaderboardElement = document.getElementById('leaderboard');
        const leaderboardEntries = document.getElementById('leaderboard-entries');
        const gameOverElement = document.getElementById('game-over');
        const finalScoreElement = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const skinOptions = document.querySelectorAll('.skin-option');

        // Настройки игры
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Состояние игры
        let gameState = {
            started: false,
            nickname: '',
            playerColor: '#FFFFFF',
            boost: 100,
            lastBoostTime: 0,
            isBoosting: false,
            topPlayers: [],
            controlSensitivity: 0.5 // Чувствительность управления
        };

        // Камера
        let camera = {
            x: 0,
            y: 0,
            width: canvas.width,
            height: canvas.height,
            zoom: 1
        };

        // Игрок
        let player = {
            x: 0,
            y: 0,
            radius: 15, // Увеличенный размер
            speed: 4,
            boostSpeed: 7,
            angle: 0,
            tail: [],
            length: 10,
            score: 0,
            color: '#FFFFFF',
            name: '',
            segments: [],
            mass: 15
        };

        // Еда
        let food = [];
        const foodCount = 300;

        // Враги
        let enemies = [];
        const enemyCount = 20;

        // Выбор скина
        let selectedColor = '#FFFFFF';
        skinOptions.forEach(option => {
            option.addEventListener('click', () => {
                skinOptions.forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                selectedColor = option.getAttribute('data-color');
            });
        });

        // Генерация еды
        function generateFood() {
            for (let i = 0; i < foodCount; i++) {
                food.push({
                    x: Math.random() * 6000 - 3000,
                    y: Math.random() * 6000 - 3000,
                    radius: 8, // Увеличенный размер еды
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                    mass: 1
                });
            }
        }

        // Генерация врагов
        function generateEnemies() {
            for (let i = 0; i < enemyCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = 500 + Math.random() * 1500;
                const x = player.x + Math.cos(angle) * distance;
                const y = player.y + Math.sin(angle) * distance;
                
                const colors = ['#FF5252', '#FFEB3B', '#4CAF50', '#2196F3', '#9C27B0', '#FF9800', '#E91E63'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const size = 15 + Math.random() * 10;
                
                enemies.push({
                    x: x,
                    y: y,
                    radius: size,
                    speed: 1.5 + Math.random() * 2,
                    angle: angle,
                    tail: [],
                    length: 15 + Math.floor(Math.random() * 40),
                    color: color,
                    name: `Bot${Math.floor(Math.random() * 1000)}`,
                    score: Math.floor(Math.random() * 200),
                    segments: [],
                    mass: size,
                    isBot: true
                });
            }
        }

        // Обновление хвоста
        function updateTail(entity) {
            entity.tail.unshift({ x: entity.x, y: entity.y });
            if (entity.tail.length > entity.length) {
                entity.tail.pop();
            }
            
            // Создание сегментов для плавного хвоста
            entity.segments = [];
            for (let i = 0; i < entity.tail.length; i++) {
                const prev = i === 0 ? {x: entity.x, y: entity.y} : entity.tail[i-1];
                const curr = entity.tail[i];
                
                const radius = entity.radius * (0.4 + 0.6 * (1 - i / entity.length));
                entity.segments.push({
                    x: curr.x,
                    y: curr.y,
                    radius: radius,
                    mass: radius
                });
            }
        }

        // Проверка столкновений
        function checkCollision(x1, y1, r1, x2, y2, r2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return dx * dx + dy * dy < (r1 + r2) * (r1 + r2);
        }

        // Преобразование мировых координат в экранные
        function worldToScreen(x, y) {
            return {
                x: (x - camera.x) * camera.zoom + camera.width / 2,
                y: (y - camera.y) * camera.zoom + camera.height / 2
            };
        }

        // Отрисовка круга с учетом камеры
        function drawCircle(x, y, radius, color) {
            const screenPos = worldToScreen(x, y);
            const screenRadius = radius * camera.zoom;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Отрисовка сегментов хвоста
        function drawTailSegments(entity) {
            for (let i = 0; i < entity.segments.length; i++) {
                const segment = entity.segments[i];
                const screenPos = worldToScreen(segment.x, segment.y);
                const screenRadius = segment.radius * camera.zoom;
                
                // Градиент для хвоста
                const gradient = ctx.createRadialGradient(
                    screenPos.x, screenPos.y, 0,
                    screenPos.x, screenPos.y, screenRadius
                );
                gradient.addColorStop(0, entity.color);
                gradient.addColorStop(1, adjustBrightness(entity.color, -0.3));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, screenRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Изменение яркости цвета
        function adjustBrightness(color, amount) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);

            const newR = Math.max(0, Math.min(255, r + Math.round(255 * amount)));
            const newG = Math.max(0, Math.min(255, g + Math.round(255 * amount)));
            const newB = Math.max(0, Math.min(255, b + Math.round(255 * amount)));

            return `#${((newR << 16) | (newG << 8) | newB).toString(16).padStart(6, '0')}`;
        }

        // Отрисовка имени игрока
        function drawName(entity) {
            if (!entity.name) return;
            
            const screenPos = worldToScreen(entity.x, entity.y);
            const fontSize = Math.max(12, entity.radius * camera.zoom * 0.8);
            
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2 * camera.zoom;
            ctx.strokeText(entity.name, screenPos.x, screenPos.y - entity.radius * camera.zoom - 5);
            ctx.fillText(entity.name, screenPos.x, screenPos.y - entity.radius * camera.zoom - 5);
            
            // Отрисовка счета для топ игроков
            if (entity.score > 50) {
                ctx.font = `${fontSize * 0.8}px Arial`;
                ctx.strokeText(entity.score, screenPos.x, screenPos.y - entity.radius * camera.zoom - 15 - fontSize * 0.5);
                ctx.fillText(entity.score, screenPos.x, screenPos.y - entity.radius * camera.zoom - 15 - fontSize * 0.5);
            }
        }

        // Обновление списка лидеров
        function updateLeaderboard() {
            // Создаем массив всех игроков (игрок + враги)
            const allPlayers = [player, ...enemies];
            
            // Сортируем по убыванию счета
            const sortedPlayers = [...allPlayers].sort((a, b) => b.score - a.score);
            
            // Берем топ-5
            gameState.topPlayers = sortedPlayers.slice(0, 5);
            
            // Обновляем отображение
            leaderboardEntries.innerHTML = '';
            gameState.topPlayers.forEach((p, index) => {
                const entry = document.createElement('div');
                entry.className = `leaderboard-entry ${p === player ? 'leaderboard-you' : ''}`;
                entry.innerHTML = `
                    <span>${index + 1}. ${p.name}</span>
                    <span>${p.score}</span>
                `;
                leaderboardEntries.appendChild(entry);
            });
        }

        // Проверка убийства бота
        function checkKillEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Проверяем столкновение головы игрока с телом бота
                for (let j = 1; j < enemy.tail.length; j++) {
                    if (checkCollision(
                        player.x, player.y, player.radius,
                        enemy.tail[j].x, enemy.tail[j].y, enemy.radius * 0.8
                    )) {
                        // Игрок убил бота - добавляем очки и удаляем бота
                        player.score += Math.floor(enemy.score * 0.5);
                        player.length += Math.floor(enemy.length * 0.3);
                        
                        // Создаем еду из останков бота
                        createFoodFromEnemy(enemy);
                        
                        enemies.splice(i, 1);
                        scoreElement.textContent = `Score: ${player.score}`;
                        break;
                    }
                }
                
                // Проверяем столкновение тела игрока с головой бота
                for (let j = 1; j < player.tail.length; j++) {
                    if (checkCollision(
                        enemy.x, enemy.y, enemy.radius,
                        player.tail[j].x, player.tail[j].y, player.radius * 0.8
                    )) {
                        // Бот убит телом игрока
                        player.score += Math.floor(enemy.score * 0.5);
                        player.length += Math.floor(enemy.length * 0.3);
                        
                        // Создаем еду из останков бота
                        createFoodFromEnemy(enemy);
                        
                        enemies.splice(i, 1);
                        scoreElement.textContent = `Score: ${player.score}`;
                        break;
                    }
                }
            }
        }

        // Создание еды из убитого врага
        function createFoodFromEnemy(enemy) {
            const pieces = 10 + Math.floor(enemy.mass / 5);
            for (let i = 0; i < pieces; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * enemy.radius * 2;
                
                food.push({
                    x: enemy.x + Math.cos(angle) * distance,
                    y: enemy.y + Math.sin(angle) * distance,
                    radius: 5 + Math.random() * 5,
                    color: enemy.color,
                    mass: 1
                });
            }
        }

        // Основной цикл игры
        function gameLoop() {
            if (!gameState.started) return;

            // Очистка экрана
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Масштабирование камеры в зависимости от размера игрока
            camera.zoom = Math.min(2, Math.max(0.5, 1 / (1 + player.mass * 0.005)));
            
            // Обновление камеры (плавное следование за игроком)
            camera.x += (player.x - camera.x) * 0.1;
            camera.y += (player.y - camera.y) * 0.1;

            // Управление игроком (упрощенное)
            if (window.mouseX !== undefined && window.mouseY !== undefined) {
                const screenCenter = worldToScreen(player.x, player.y);
                const targetAngle = Math.atan2(
                    screenCenter.y - window.mouseY,
                    screenCenter.x - window.mouseX
                );
                
                // Плавное изменение угла с учетом чувствительности
                const angleDiff = ((targetAngle - player.angle + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
                player.angle += angleDiff * gameState.controlSensitivity * 0.1;
            }

            // Ускорение (boost)
            const currentTime = Date.now();
            if (gameState.isBoosting && gameState.boost > 0) {
                player.speed = player.boostSpeed;
                gameState.boost = Math.max(0, gameState.boost - 0.5);
                boostBar.style.width = `${gameState.boost}%`;
            } else {
                player.speed = 4;
                if (currentTime - gameState.lastBoostTime > 100 && gameState.boost < 100) {
                    gameState.boost = Math.min(100, gameState.boost + 0.2);
                    boostBar.style.width = `${gameState.boost}%`;
                    gameState.lastBoostTime = currentTime;
                }
            }

            // Движение игрока
            player.x -= Math.cos(player.angle) * player.speed;
            player.y -= Math.sin(player.angle) * player.speed;

            // Обновление хвоста игрока
            updateTail(player);

            // Отрисовка хвоста игрока
            drawTailSegments(player);

            // Отрисовка головы игрока
            drawCircle(player.x, player.y, player.radius, player.color);
            drawName(player);

            // Проверка сбора еды
            for (let i = food.length - 1; i >= 0; i--) {
                if (checkCollision(player.x, player.y, player.radius, food[i].x, food[i].y, food[i].radius)) {
                    player.length += 2;
                    player.score += 1;
                    player.mass += 0.1;
                    scoreElement.textContent = `Score: ${player.score}`;
                    food.splice(i, 1);
                    
                    // Добавляем новую еду в случайном месте мира
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 500 + Math.random() * 1500;
                    food.push({
                        x: player.x + Math.cos(angle) * distance,
                        y: player.y + Math.sin(angle) * distance,
                        radius: 8,
                        color: `hsl(${Math.random() * 360}, 100%, 50%)`,
                        mass: 1
                    });
                }
            }

            // Отрисовка еды
            food.forEach(f => {
                drawCircle(f.x, f.y, f.radius, f.color);
            });

            // Движение и отрисовка врагов
            enemies.forEach(enemy => {
                // ИИ врагов - простой патруль с небольшим преследованием игрока
                if (Math.random() < 0.02) {
                    if (Math.random() < 0.3 && player.score > 10) {
                        // Иногда преследуют игрока (если он достаточно большой)
                        enemy.angle = Math.atan2(
                            player.y - enemy.y,
                            player.x - enemy.x
                        );
                        
                        // Избегаем столкновений с более крупными змейками
                        if (player.mass > enemy.mass * 1.5) {
                            enemy.angle += Math.PI; // Разворачиваемся от игрока
                        }
                    } else {
                        // Или просто случайное движение
                        enemy.angle += (Math.random() - 0.5) * 1.5;
                    }
                }

                enemy.x += Math.cos(enemy.angle) * enemy.speed;
                enemy.y += Math.sin(enemy.angle) * enemy.speed;

                // Обновление хвоста врага
                updateTail(enemy);

                // Отрисовка хвоста врага
                drawTailSegments(enemy);

                // Отрисовка головы врага
                drawCircle(enemy.x, enemy.y, enemy.radius, enemy.color);
                drawName(enemy);

                // Проверка столкновения головы врага с головой игрока
                if (checkCollision(player.x, player.y, player.radius, 
                                 enemy.x, enemy.y, enemy.radius)) {
                    if (player.mass > enemy.mass * 1.2) {
                        // Игрок больше - убиваем врага
                        player.score += Math.floor(enemy.score * 0.5);
                        player.length += Math.floor(enemy.length * 0.3);
                        createFoodFromEnemy(enemy);
                        enemies.splice(enemies.indexOf(enemy), 1);
                        scoreElement.textContent = `Score: ${player.score}`;
                    } else if (enemy.mass > player.mass * 1.2) {
                        // Враг больше - игрок погибает
                        gameOver();
                        return;
                    }
                }

                // Враги тоже собирают еду
                for (let i = food.length - 1; i >= 0; i--) {
                    if (checkCollision(enemy.x, enemy.y, enemy.radius, food[i].x, food[i].y, food[i].radius)) {
                        enemy.length += 2;
                        enemy.score += 1;
                        enemy.mass += 0.1;
                        food.splice(i, 1);
                        break;
                    }
                }
            });

            // Проверка убийства ботов
            checkKillEnemies();

            // Респавн врагов, если их стало мало
            if (enemies.length < enemyCount * 0.5) {
                generateEnemies();
            }

            // Обновление списка лидеров
            updateLeaderboard();

            requestAnimationFrame(gameLoop);
        }

        // Конец игры
        function gameOver() {
            gameState.started = false;
            finalScoreElement.textContent = `Score: ${player.score}`;
            gameOverElement.style.display = 'flex';
            leaderboardElement.style.display = 'none';
            boostElement.style.display = 'none';
        }

        // Сброс игры
        function resetGame() {
            player = {
                x: 0,
                y: 0,
                radius: 15,
                speed: 4,
                boostSpeed: 7,
                angle: 0,
                tail: [],
                segments: [],
                length: 10,
                score: 0,
                color: gameState.playerColor,
                name: gameState.nickname || 'Player',
                mass: 15
            };
            food = [];
            enemies = [];
            gameState.boost = 100;
            boostBar.style.width = '100%';
            generateFood();
            generateEnemies();
            scoreElement.textContent = 'Score: 0';
        }

        // Обработчики событий
        startBtn.addEventListener('click', () => {
            gameState.nickname = nicknameInput.value.trim() || 'Player';
            gameState.playerColor = selectedColor;
            gameState.started = true;
            menuElement.style.display = 'none';
            boostElement.style.display = 'block';
            leaderboardElement.style.display = 'block';
            resetGame();
            gameLoop();
        });

        playAgainBtn.addEventListener('click', () => {
            gameOverElement.style.display = 'none';
            gameState.started = true;
            boostElement.style.display = 'block';
            leaderboardElement.style.display = 'block';
            resetGame();
            gameLoop();
        });

        instructionsBtn.addEventListener('click', () => {
            alert("HOW TO PLAY:\n\n1. Move your mouse to control your snake\n2. Press SPACE or LEFT MOUSE BUTTON to boost\n3. Eat colored dots to grow\n4. Kill other snakes by making them crash into your body\n5. Avoid crashing into bigger snakes\n\nTOP PLAYERS are displayed in the leaderboard on the right.");
        });

        // Управление ускорением
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameState.started) {
                e.preventDefault();
                gameState.isBoosting = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                gameState.isBoosting = false;
            }
        });

        canvas.addEventListener('mousedown', () => {
            if (gameState.started) {
                gameState.isBoosting = true;
            }
        });

        canvas.addEventListener('mouseup', () => {
            gameState.isBoosting = false;
        });

        canvas.addEventListener('touchstart', () => {
            if (gameState.started) {
                gameState.isBoosting = true;
            }
        });

        canvas.addEventListener('touchend', () => {
            gameState.isBoosting = false;
        });

        // Отслеживание мыши/касания
        window.mouseX = undefined;
        window.mouseY = undefined;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            window.mouseX = e.clientX - rect.left;
            window.mouseY = e.clientY - rect.top;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            window.mouseX = touch.clientX - rect.left;
            window.mouseY = touch.clientY - rect.top;
        }, { passive: false });

        // Инициализация
        boostElement.style.display = 'none';
        leaderboardElement.style.display = 'none';
        generateFood();
        generateEnemies();
    </script>
</body>
</html>
